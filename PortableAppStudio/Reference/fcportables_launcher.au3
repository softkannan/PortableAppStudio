#NoTrayIcon
$SCRIPTPROCESSES=PROCESSLIST(@SCRIPTNAME)
IF $SCRIPTPROCESSES[0][0]>1 THEN EXIT (MSGBOX(16,"Error",'Only one instance of "'&@SCRIPTNAME&'" allowed.'))
GLOBAL $SCRIPTNAME=STRINGLEFT(@SCRIPTNAME,STRINGLEN(@SCRIPTNAME)-4),$DATA=@SCRIPTDIR&"\Data\",$INIFILE=$DATA&$SCRIPTNAME&".ini",$PRL=$DATA&$SCRIPTNAME&".prl",$PFL=$DATA&$SCRIPTNAME&".pfl",$REGTYPES[11]=["REG_NONE","REG_SZ","REG_EXPAND_SZ","REG_BINARY","REG_DWORD","REG_DWORD_BIG_ENDIAN","REG_LINK","REG_MULTI_SZ","REG_RESOURCE_LIST","REG_FULL_RESOURCE_DESCRIPTOR","REG_RESOURCE_REQUIREMENTS_LIST"]
$APPLICATIONFOLDER=@SCRIPTDIR&"\"&INIREAD($INIFILE,"application","folder","")

DIM $ENVGETAR[ENVSET("system32",@SYSTEMDIR)+ENVSET("applicationfolder",$APPLICATIONFOLDER)+ENVSET("scriptdir",@SCRIPTDIR)+4]
GLOBAL $ENVARRAY[7]=[6,"%applicationfolder%","%scriptdir%","%system32%","%allusersprofile%","%userprofile%","%commonprogramfiles%"]
$ENVGETAR[0]=$ENVARRAY[0]
FOR $I=1 TO $ENVARRAY[0]
	$ENVGETAR[$I]=ENVGET(STRINGMID($ENVARRAY[$I],2,STRINGLEN($ENVARRAY[$I])-2))
NEXT

IF NOT ISADMIN()AND FILEEXISTS(@SCRIPTDIR&"\Data\"&$ENVARRAY[1])THEN MSGBOX(48,$SCRIPTNAME,@USERNAME&" is not an Administrator on this system."&@CRLF&$SCRIPTNAME&" might need administrative rights in order to function correctly.",5)
IF FILEEXISTS($PRL)THEN REGSET()
IF FILEEXISTS($PFL)THEN FILESET()
SHELLEXECUTEWAIT($APPLICATIONFOLDER&"\"&INIREAD($INIFILE,"application","file",""),"",$APPLICATIONFOLDER)
DO
	SLEEP(500)
UNTIL NOT PROCESSEXISTS(INIREAD($INIFILE,"application","filewait",""))
IF FILEEXISTS($PRL)THEN REGRESTORE()
IF FILEEXISTS($PFL)THEN FILERESTORE()


FUNC REGSET()
$FILELINES=FILECOUNTLINES($PRL)
FOR $LINENUMBER=1 TO $FILELINES
	$REGINFO=STRINGSPLIT(FILEREADLINE($PRL,$LINENUMBER),", ",1)
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($REGINFO[1],$ENVARRAY[$I])THEN
			$REGINFO[1]=STRINGREPLACE($REGINFO[1],$ENVARRAY[$I],$ENVGETAR[$I])
			EXITLOOP
		ENDIF
	NEXT
	$HOSTVALUE=REGREAD($REGINFO[1],$REGINFO[2])
	$HOSTTYPE=$REGTYPES[@EXTENDED]
	$HOSTVALUE=STRINGREPLACE($HOSTVALUE,@LF,"%lf%")
	$HOSTVALUE=STRINGREPLACE($HOSTVALUE,@CR,"%cr%")
	$REGINFO[4]=STRINGREPLACE($REGINFO[4],"%lf%",@LF)
	$REGINFO[4]=STRINGREPLACE($REGINFO[4],"%cr%",@CR)
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($REGINFO[1],$ENVARRAY[$I])THEN
			$REGINFO[1]=STRINGREPLACE($REGINFO[1],$ENVARRAY[$I],$ENVGETAR[$I])
			EXITLOOP
		ENDIF
	NEXT
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($REGINFO[4],$ENVARRAY[$I])THEN
			$REGINFO[4]=STRINGREPLACE($REGINFO[4],$ENVARRAY[$I],$ENVGETAR[$I])
			EXITLOOP
		ENDIF
	NEXT
	FILEWRITELINE($PRL&".bup",$REGINFO[1]&", "&$REGINFO[2]&", "&$HOSTTYPE&", "&$HOSTVALUE)
	REGWRITE($REGINFO[1],$REGINFO[2],$REGINFO[3],$REGINFO[4])
NEXT
ENDFUNC


FUNC FILESET()
$FILELINES=FILECOUNTLINES($PFL)
FOR $LINENUMBER=1 TO $FILELINES
	$PAFFILENAME=FILEREADLINE($PFL,$LINENUMBER)
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($PAFFILENAME,$ENVARRAY[$I])THEN EXITLOOP
	NEXT
	IF $I=1 AND NOT ISADMIN()THEN CONTINUELOOP
	$FILENAME=STRINGREPLACE($PAFFILENAME,$ENVARRAY[$I],$ENVGETAR[$I],1)
	IF FILEEXISTS($FILENAME)THEN FILECOPY($FILENAME,$DATA&$PAFFILENAME&".bup")
	FILECOPY($DATA&$PAFFILENAME,$FILENAME,9)
NEXT
ENDFUNC


FUNC REGRESTORE()
FILEDELETE($PRL)
$FILELINES=FILECOUNTLINES($PRL&".bup")
FOR $LINENUMBER=1 TO $FILELINES
	$REGINFO=STRINGSPLIT(FILEREADLINE($PRL&".bup",$LINENUMBER),", ",1)
	IF $REGINFO[0]<4 THEN REDIM $REGINFO[5]
	$HOSTVALUE=REGREAD($REGINFO[1],$REGINFO[2])
	$HOSTTYPE=$REGTYPES[@EXTENDED]
	$REGINFO[4]=STRINGREPLACE($REGINFO[4],"%lf%",@LF)
	$REGINFO[4]=STRINGREPLACE($REGINFO[4],"%cr%",@CR)
	IF $REGINFO[3]="REG_NONE" THEN
	IF REGDELETE($REGINFO[1],$REGINFO[2])THEN $REGINFO[1]&="\"
		DO
			$REGINFO[1]=STRINGTRIMRIGHT($REGINFO[1],STRINGLEN($REGINFO[1])-STRINGINSTR($REGINFO[1],"\",0,-1)+1)
			IF NOT (REGENUMVAL($REGINFO[1],1)=REGENUMKEY($REGINFO[1],1))THEN EXITLOOP
		UNTIL NOT REGDELETE($REGINFO[1])=1
	ELSE
		REGWRITE($REGINFO[1],$REGINFO[2],$REGINFO[3],$REGINFO[4])
	ENDIF
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($REGINFO[1],$ENVGETAR[$I])THEN
			$REGINFO[1]=STRINGREPLACE($REGINFO[1],$ENVGETAR[$I],$ENVARRAY[$I])
			EXITLOOP
		ENDIF
	NEXT
	$HOSTVALUE=STRINGREPLACE($HOSTVALUE,@LF,"%lf%")
	$HOSTVALUE=STRINGREPLACE($HOSTVALUE,@CR,"%cr%")
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($REGINFO[1],$ENVGETAR[$I])THEN
			$REGINFO[1]=STRINGREPLACE($REGINFO[1],$ENVGETAR[$I],$ENVARRAY[$I])
			EXITLOOP
		ENDIF
	NEXT
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($HOSTVALUE,$ENVGETAR[$I])THEN
			$HOSTVALUE=STRINGREPLACE($HOSTVALUE,$ENVGETAR[$I],$ENVARRAY[$I])
			EXITLOOP
		ENDIF
	NEXT
	FILEWRITELINE($PRL,$REGINFO[1]&", "&$REGINFO[2]&", "&$HOSTTYPE&", "&$HOSTVALUE)
NEXT
FILEDELETE($PRL&".bup")
ENDFUNC


FUNC FILERESTORE()
$FILELINES=FILECOUNTLINES($PFL)
FOR $LINENUMBER=1 TO $FILELINES
	$PAFFILENAME=FILEREADLINE($PFL,$LINENUMBER)
	FOR $I=1 TO $ENVARRAY[0]
		IF STRINGINSTR($PAFFILENAME,$ENVARRAY[$I])THEN EXITLOOP
	NEXT
	IF $I=1 AND NOT ISADMIN()THEN CONTINUELOOP
	$FILENAME=STRINGREPLACE($PAFFILENAME,$ENVARRAY[$I],$ENVGETAR[$I],1)
	FILECOPY($FILENAME,$DATA&$PAFFILENAME,9)
	IF FILEEXISTS($DATA&$PAFFILENAME&".bup")THEN
		FILECOPY($DATA&$PAFFILENAME&".bup",$FILENAME,9)
		FILEDELETE($DATA&$PAFFILENAME&".bup")
	ELSE
	FILEDELETE($FILENAME)
	DO
		$FILENAME=STRINGTRIMRIGHT($FILENAME,STRINGLEN($FILENAME)-STRINGINSTR($FILENAME,"\",0,-1)+1)
		$DIRSIZE=DIRGETSIZE($FILENAME,1)
		IF @ERROR THEN EXITLOOP
		IF $DIRSIZE[1]THEN EXITLOOP
	UNTIL NOT DIRREMOVE($FILENAME,1)=1
	ENDIF
NEXT
ENDFUNC

FUNC FILECOUNTLINES($FILE)
LOCAL $N=FILEGETSIZE($FILE)-1
RETURN STRINGLEN(STRINGADDCR(FILEREAD($FILE,$N)))-$N+1
ENDFUNC
; DeTokenise by myAut2Exe >The Open Source AutoIT/AutoHotKey script decompiler< - dmod 2.12 build(269)

